# =============================================================================
# Time Series Bagger
# =============================================================================

"""
    TimeSeriesBagger{M, S<:BootstrapStrategy}

Generic time-series-aware bagging wrapper.

Trains multiple copies of a base model on bootstrap samples
generated by the specified strategy, then aggregates predictions.

# Type Parameters
- `M`: Base model type (must support `fit!(model, X, y)` and `predict(model, X)`)
- `S`: Bootstrap strategy type

# Fields
- `base_model::M`: Template model to clone for each estimator
- `strategy::S`: Bootstrap resampling strategy
- `n_estimators::Int`: Number of bootstrap models
- `aggregation::Symbol`: How to aggregate predictions (`:mean` or `:median`)
- `random_state::Union{Int, Nothing}`: Random seed for reproducibility
- `models::Vector{M}`: Fitted models (populated after fit!)
- `fitted::Bool`: Whether fit! has been called

# Example
```julia
# Define a simple model
mutable struct LinearModel
    coef::Vector{Float64}
    LinearModel() = new(Float64[])
end

function fit!(m::LinearModel, X, y)
    m.coef = X \\ y
    return m
end

predict(m::LinearModel, X) = X * m.coef

# Create bagger
bagger = TimeSeriesBagger(
    base_model=LinearModel(),
    strategy=StationaryBootstrap(expected_block_length=10.0),
    n_estimators=50
)
fit!(bagger, X_train, y_train)
predictions = predict(bagger, X_test)
mean_pred, std_pred = predict_with_uncertainty(bagger, X_test)
```
"""
mutable struct TimeSeriesBagger{M, S<:BootstrapStrategy}
    base_model::M
    strategy::S
    n_estimators::Int
    aggregation::Symbol
    random_state::Union{Int, Nothing}
    models::Vector{M}
    fitted::Bool

    function TimeSeriesBagger(;
            base_model::M,
            strategy::S,
            n_estimators::Int=50,
            aggregation::Symbol=:mean,
            random_state::Union{Int, Nothing}=nothing) where {M, S<:BootstrapStrategy}
        @assert n_estimators > 0 "n_estimators must be positive, got $n_estimators"
        @assert aggregation in (:mean, :median) "aggregation must be :mean or :median, got $aggregation"
        new{M, S}(base_model, strategy, n_estimators, aggregation,
                  random_state, M[], false)
    end
end

"""
    fit!(bagger::TimeSeriesBagger, X, y) -> TimeSeriesBagger

Fit bagger on training data.

Generates bootstrap samples using the strategy, then fits a clone
of the base model on each sample.
"""
function fit!(bagger::TimeSeriesBagger, X::AbstractMatrix, y::AbstractVector)
    # Set up RNG
    rng = if isnothing(bagger.random_state)
        Random.default_rng()
    else
        Random.MersenneTwister(bagger.random_state)
    end

    # Generate bootstrap samples
    samples = bootstrap_sample(bagger.strategy, X, y, bagger.n_estimators, rng)

    # Fit models on each sample
    bagger.models = map(samples) do (X_boot, y_boot)
        model = deepcopy(bagger.base_model)
        fit!(model, X_boot, y_boot)
        model
    end

    bagger.fitted = true
    return bagger
end

"""
    predict(bagger::TimeSeriesBagger, X) -> Vector{Float64}

Generate aggregated predictions.

Returns mean or median of individual model predictions based on
the `aggregation` setting.
"""
function predict(bagger::TimeSeriesBagger, X::AbstractMatrix)
    @assert bagger.fitted "Must call fit! before predict"

    all_preds = _get_all_predictions(bagger, X)

    if bagger.aggregation == :mean
        return vec(mean(all_preds, dims=2))
    else
        return vec(mapslices(median, all_preds, dims=2))
    end
end

"""
    _get_all_predictions(bagger, X) -> Matrix{Float64}

Get predictions from all estimators.

Returns matrix of shape (n_test, n_estimators).
"""
function _get_all_predictions(bagger::TimeSeriesBagger, X::AbstractMatrix)
    n_test = size(X, 1)
    all_preds = Matrix{Float64}(undef, n_test, bagger.n_estimators)

    for (i, model) in enumerate(bagger.models)
        preds = predict(model, X)
        # Handle both vector and scalar returns
        if preds isa Number
            all_preds[:, i] .= preds
        else
            all_preds[:, i] = preds
        end
    end

    return all_preds
end

"""
    predict_with_uncertainty(bagger::TimeSeriesBagger, X) -> Tuple{Vector{Float64}, Vector{Float64}}

Generate predictions with uncertainty estimates.

# Returns
- `(mean_pred, std_pred)`: Mean predictions and standard deviations
"""
function predict_with_uncertainty(bagger::TimeSeriesBagger, X::AbstractMatrix)
    @assert bagger.fitted "Must call fit! before predict_with_uncertainty"

    all_preds = _get_all_predictions(bagger, X)

    mean_pred = vec(mean(all_preds, dims=2))
    std_pred = vec(std(all_preds, dims=2))

    return (mean_pred, std_pred)
end

"""
    predict_interval(bagger::TimeSeriesBagger, X; alpha=0.1) -> Tuple

Generate prediction intervals from bootstrap distribution.

# Arguments
- `alpha::Float64`: Miscoverage rate (default 0.1 for 90% intervals)

# Returns
- `(mean_pred, lower, upper)`: Mean predictions with lower/upper bounds
"""
function predict_interval(bagger::TimeSeriesBagger, X::AbstractMatrix; alpha::Float64=0.1)
    @assert bagger.fitted "Must call fit! before predict_interval"
    @assert 0 < alpha < 1 "alpha must be in (0, 1), got $alpha"

    all_preds = _get_all_predictions(bagger, X)

    mean_pred = vec(mean(all_preds, dims=2))

    # Compute quantiles row-wise
    lower_q = alpha / 2
    upper_q = 1 - alpha / 2

    lower = vec(mapslices(x -> quantile(x, lower_q), all_preds, dims=2))
    upper = vec(mapslices(x -> quantile(x, upper_q), all_preds, dims=2))

    return (mean_pred, lower, upper)
end
